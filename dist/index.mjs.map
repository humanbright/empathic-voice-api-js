{"version":3,"sources":["../src/lib/useSoundPlayer.ts","../src/lib/convertFrequencyScale.ts","../src/lib/generateEmptyFft.ts","../src/lib/useMicrophone.ts","../src/lib/VoiceProvider.tsx","../src/lib/noop.ts","../src/lib/useCallDuration.ts","../src/lib/useEncoding.ts","../src/lib/useMessages.ts","../src/utils/index.ts","../src/lib/useVoiceClient.ts","../src/index.ts"],"sourcesContent":["import { type AudioOutputMessage, base64ToBlob } from '@humeai/voice';\nimport { useCallback, useRef, useState } from 'react';\n\nimport { convertLinearFrequenciesToBark } from './convertFrequencyScale';\nimport { generateEmptyFft } from './generateEmptyFft';\n\nexport const useSoundPlayer = (props: {\n  onError: (message: string) => void;\n  onPlayAudio: (id: string) => void;\n}) => {\n  const [isPlaying, setIsPlaying] = useState(false);\n  const [fft, setFft] = useState<number[]>(generateEmptyFft());\n\n  const audioContext = useRef<AudioContext | null>(null);\n  const analyserNode = useRef<AnalyserNode | null>(null);\n  const isInitialized = useRef(false);\n\n  const clipQueue = useRef<\n    Array<{\n      id: string;\n      buffer: AudioBuffer;\n    }>\n  >([]);\n  const isProcessing = useRef(false);\n  const currentlyPlayingAudioBuffer = useRef<AudioBufferSourceNode | null>(\n    null,\n  );\n  const frequencyDataIntervalId = useRef<number | null>(null);\n\n  const onPlayAudio = useRef<typeof props.onPlayAudio>(props.onPlayAudio);\n  onPlayAudio.current = props.onPlayAudio;\n\n  const onError = useRef<typeof props.onError>(props.onError);\n  onError.current = props.onError;\n\n  const playNextClip = useCallback(() => {\n    if (analyserNode.current === null || audioContext.current === null) {\n      onError.current('Audio environment is not initialized');\n      return;\n    }\n\n    if (clipQueue.current.length === 0 || isProcessing.current) {\n      return;\n    }\n\n    const nextClip = clipQueue.current.shift();\n    if (!nextClip) return;\n\n    isProcessing.current = true;\n    setIsPlaying(true);\n\n    // Use AudioBufferSourceNode for audio playback.\n    // Safari suffered a truncation issue using HTML5 audio playback\n    const bufferSource = audioContext.current.createBufferSource();\n\n    bufferSource.buffer = nextClip.buffer;\n\n    bufferSource.connect(analyserNode.current);\n\n    currentlyPlayingAudioBuffer.current = bufferSource;\n\n    const updateFrequencyData = () => {\n      const bufferSampleRate = bufferSource.buffer?.sampleRate;\n\n      if (!analyserNode.current || typeof bufferSampleRate === 'undefined')\n        return;\n\n      const dataArray = new Uint8Array(analyserNode.current.frequencyBinCount); // frequencyBinCount is 1/2 of fftSize\n      analyserNode.current.getByteFrequencyData(dataArray); // Using getByteFrequencyData for performance\n\n      const barkFrequencies = convertLinearFrequenciesToBark(\n        dataArray,\n        bufferSampleRate,\n      );\n\n      setFft(() => barkFrequencies);\n    };\n\n    frequencyDataIntervalId.current = window.setInterval(\n      updateFrequencyData,\n      5,\n    );\n\n    bufferSource.start(0);\n    onPlayAudio.current(nextClip.id);\n\n    bufferSource.onended = () => {\n      if (frequencyDataIntervalId.current) {\n        clearInterval(frequencyDataIntervalId.current);\n      }\n      setFft(generateEmptyFft());\n      bufferSource.disconnect();\n      isProcessing.current = false;\n      setIsPlaying(false);\n      currentlyPlayingAudioBuffer.current = null;\n      playNextClip();\n    };\n  }, []);\n\n  const initPlayer = useCallback(() => {\n    const initAudioContext = new AudioContext();\n    audioContext.current = initAudioContext;\n\n    // Use AnalyserNode to get fft frequency data for visualizations\n    const analyser = initAudioContext.createAnalyser();\n    analyser.connect(initAudioContext.destination);\n    analyser.fftSize = 2048; // Must be a power of 2\n    analyserNode.current = analyser;\n\n    isInitialized.current = true;\n  }, []);\n\n  const addToQueue = useCallback(\n    async (message: AudioOutputMessage) => {\n      if (!isInitialized.current || !audioContext.current) {\n        onError.current('Audio player has not been initialized');\n        return;\n      }\n\n      try {\n        const blob = base64ToBlob(message.data, 'audio/mp3');\n        const arrayBuffer = await blob.arrayBuffer();\n        const audioBuffer =\n          await audioContext.current.decodeAudioData(arrayBuffer);\n\n        clipQueue.current.push({\n          id: message.id,\n          buffer: audioBuffer,\n        });\n\n        // playNextClip will iterate the clipQueue upon finishing the playback of the current audio clip, so we can\n        // just call playNextClip here if it's the only one in the queue\n        if (clipQueue.current.length === 1) {\n          playNextClip();\n        }\n      } catch (e) {\n        const eMessage = e instanceof Error ? e.message : 'Unknown error';\n        onError.current(`Failed to add clip to queue: ${eMessage}`);\n      }\n    },\n    [playNextClip],\n  );\n\n  const stopAll = useCallback(() => {\n    isInitialized.current = false;\n    isProcessing.current = false;\n    setIsPlaying(false);\n\n    if (frequencyDataIntervalId.current) {\n      window.clearInterval(frequencyDataIntervalId.current);\n    }\n\n    if (currentlyPlayingAudioBuffer.current) {\n      currentlyPlayingAudioBuffer.current.disconnect();\n      currentlyPlayingAudioBuffer.current = null;\n    }\n\n    if (analyserNode.current) {\n      analyserNode.current.disconnect();\n      analyserNode.current = null;\n    }\n\n    if (audioContext.current) {\n      void audioContext.current\n        .close()\n        .then(() => {\n          audioContext.current = null;\n        })\n        .catch(() => {\n          // .close() rejects if the audio context is already closed.\n          // Therefore, we just need to catch the error, but we don't need to\n          // do anything with it.\n          return null;\n        });\n    }\n\n    clipQueue.current = [];\n    setFft(generateEmptyFft());\n  }, []);\n\n  const clearQueue = useCallback(() => {\n    if (currentlyPlayingAudioBuffer.current) {\n      currentlyPlayingAudioBuffer.current.stop();\n      currentlyPlayingAudioBuffer.current = null;\n    }\n\n    clipQueue.current = [];\n    isProcessing.current = false;\n    setIsPlaying(false);\n    setFft(generateEmptyFft());\n  }, []);\n\n  return {\n    addToQueue,\n    fft,\n    initPlayer,\n    isPlaying,\n    stopAll,\n    clearQueue,\n  };\n};\n","// This function converts linear-scaled frequency decibels from an AnalyserNode's frequncy data to Bark scale [https://en.wikipedia.org/wiki/Bark_scale]\n// This implementation uses a simple approach of mapping indices in the linear-scaled array to the closest\n// Bark scale center frequency and is not intended to be an accurate representation, but rather \"close-enough\" for visualization purposes\nconst barkCenterFrequencies = [\n  50, 150, 250, 350, 450, 570, 700, 840, 1000, 1170, 1370, 1600, 1850, 2150,\n  2500, 2900, 3400, 4000, 4800, 5800, 7000, 8500, 10500, 13500,\n]; // Center frequency value in Hz\n\n// Min/max values from https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode/getByteFrequencyData\nconst minValue = 0;\nconst maxValue = 255;\n\nexport function convertLinearFrequenciesToBark(\n  linearData: Uint8Array,\n  sampleRate: number,\n): number[] {\n  const maxFrequency = sampleRate / 2;\n  const frequencyResolution = maxFrequency / linearData.length;\n\n  const barkFrequencies = barkCenterFrequencies.map((barkFreq) => {\n    const linearDataIndex = Math.round(barkFreq / frequencyResolution);\n    if (linearDataIndex >= 0 && linearDataIndex < linearData.length) {\n      return (\n        (((linearData[linearDataIndex] ?? 0) - minValue) /\n          (maxValue - minValue)) *\n        2\n      );\n    } else {\n      return 0;\n    }\n  });\n\n  return barkFrequencies;\n}\n","export function generateEmptyFft(): number[] {\n  return Array.from({ length: 24 }).map(() => 0);\n}\n","// cspell:ignore dataavailable\nimport type { MimeType } from '@humeai/voice';\nimport { getSupportedMimeType } from '@humeai/voice';\nimport Meyda from 'meyda';\nimport type { MeydaFeaturesObject } from 'meyda';\nimport { useCallback, useEffect, useRef, useState } from 'react';\nimport type { MutableRefObject } from 'react';\n\nimport { generateEmptyFft } from './generateEmptyFft';\n\nexport type MicrophoneProps = {\n  streamRef: MutableRefObject<MediaStream | null>;\n  onAudioCaptured: (b: ArrayBuffer) => void;\n  onStartRecording?: () => void;\n  onStopRecording?: () => void;\n  onError: (message: string) => void;\n};\n\nexport const useMicrophone = (props: MicrophoneProps) => {\n  const { streamRef, onAudioCaptured, onError } = props;\n  const [isMuted, setIsMuted] = useState(false);\n  const isMutedRef = useRef(isMuted);\n\n  const [fft, setFft] = useState<number[]>(generateEmptyFft());\n  const currentAnalyzer = useRef<Meyda.MeydaAnalyzer | null>(null);\n  const mimeTypeRef = useRef<MimeType | null>(null);\n\n  const audioContext = useRef<AudioContext | null>(null);\n\n  const recorder = useRef<MediaRecorder | null>(null);\n\n  const sendAudio = useRef(onAudioCaptured);\n  sendAudio.current = onAudioCaptured;\n\n  const dataHandler = useCallback((event: BlobEvent) => {\n    if (isMutedRef.current) {\n      // Do not send audio if the microphone is muted\n      return;\n    }\n\n    const blob = event.data;\n\n    blob\n      .arrayBuffer()\n      .then((buffer) => {\n        if (buffer.byteLength > 0) {\n          sendAudio.current?.(buffer);\n        }\n      })\n      .catch((err) => {\n        console.log(err);\n      });\n  }, []);\n\n  const start = useCallback(() => {\n    const stream = streamRef.current;\n    if (!stream) {\n      throw new Error('No stream connected');\n    }\n\n    const context = new AudioContext();\n    audioContext.current = context;\n    const input = context.createMediaStreamSource(stream);\n\n    try {\n      currentAnalyzer.current = Meyda.createMeydaAnalyzer({\n        audioContext: context,\n        source: input,\n        featureExtractors: ['loudness'],\n        callback: (features: MeydaFeaturesObject) => {\n          const newFft = features.loudness.specific || [];\n          setFft(() => Array.from(newFft));\n        },\n      });\n\n      currentAnalyzer.current.start();\n    } catch (e: unknown) {\n      const message = e instanceof Error ? e.message : 'Unknown error';\n      console.error(`Failed to start mic analyzer: ${message}`);\n    }\n    const mimeType = mimeTypeRef.current;\n    if (!mimeType) {\n      throw new Error('No MimeType specified');\n    }\n\n    recorder.current = new MediaRecorder(stream, {\n      mimeType,\n    });\n    recorder.current.addEventListener('dataavailable', dataHandler);\n    recorder.current.start(100);\n  }, [dataHandler, streamRef, mimeTypeRef]);\n\n  const stop = useCallback(() => {\n    try {\n      if (currentAnalyzer.current) {\n        currentAnalyzer.current.stop();\n        currentAnalyzer.current = null;\n      }\n\n      if (audioContext.current) {\n        void audioContext.current\n          .close()\n          .then(() => {\n            audioContext.current = null;\n          })\n          .catch(() => {\n            // .close() rejects if the audio context is already closed.\n            // Therefore, we just need to catch the error, but we don't need to\n            // do anything with it.\n            return null;\n          });\n      }\n\n      recorder.current?.stop();\n      recorder.current?.removeEventListener('dataavailable', dataHandler);\n      recorder.current = null;\n      streamRef.current?.getTracks().forEach((track) => track.stop());\n\n      setIsMuted(false);\n    } catch (e) {\n      const message = e instanceof Error ? e.message : 'Unknown error';\n      onError(`Error stopping microphone: ${message}`);\n      console.log(e);\n      void true;\n    }\n  }, [dataHandler, onError, streamRef]);\n\n  const mute = useCallback(() => {\n    if (currentAnalyzer.current) {\n      currentAnalyzer.current.stop();\n      setFft(generateEmptyFft());\n    }\n\n    streamRef.current?.getTracks().forEach((track) => {\n      track.enabled = false;\n    });\n\n    isMutedRef.current = true;\n    setIsMuted(true);\n  }, [streamRef]);\n\n  const unmute = useCallback(() => {\n    if (currentAnalyzer.current) {\n      currentAnalyzer.current.start();\n    }\n\n    streamRef.current?.getTracks().forEach((track) => {\n      track.enabled = true;\n    });\n\n    isMutedRef.current = false;\n    setIsMuted(false);\n  }, [streamRef]);\n\n  useEffect(() => {\n    return () => {\n      try {\n        recorder.current?.stop();\n        recorder.current?.removeEventListener('dataavailable', dataHandler);\n\n        if (currentAnalyzer.current) {\n          currentAnalyzer.current.stop();\n          currentAnalyzer.current = null;\n        }\n\n        streamRef.current?.getTracks().forEach((track) => track.stop());\n        streamRef.current = null;\n      } catch (e) {\n        console.log(e);\n        void true;\n      }\n    };\n  }, [dataHandler, streamRef]);\n\n  useEffect(() => {\n    const mimeTypeResult = getSupportedMimeType();\n    if (mimeTypeResult.success) {\n      mimeTypeRef.current = mimeTypeResult.mimeType;\n    } else {\n      onError(mimeTypeResult.error.message);\n    }\n  }, [onError]);\n\n  return {\n    start,\n    stop,\n    mute,\n    unmute,\n    isMuted,\n    fft,\n  };\n};\n","import {\n  AssistantTranscriptMessage,\n  AudioOutputMessage,\n  createSocketConfig,\n  JSONErrorMessage,\n  JSONMessage,\n  SessionSettings,\n  UserInterruptionMessage,\n  UserTranscriptMessage,\n  VoiceEventMap,\n} from '@humeai/voice';\nimport React, {\n  createContext,\n  FC,\n  PropsWithChildren,\n  useCallback,\n  useContext,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n} from 'react';\n\nimport { ConnectionMessage } from './connection-message';\nimport { noop } from './noop';\nimport { useCallDuration } from './useCallDuration';\nimport { useEncoding } from './useEncoding';\nimport { useMessages } from './useMessages';\nimport { useMicrophone } from './useMicrophone';\nimport { useSoundPlayer } from './useSoundPlayer';\nimport { useVoiceClient, type VoiceReadyState } from './useVoiceClient';\n\ntype VoiceError =\n  | { type: 'socket_error'; message: string; error?: Error }\n  | { type: 'audio_error'; message: string; error?: Error }\n  | { type: 'mic_error'; message: string; error?: Error };\n\ntype VoiceStatus =\n  | {\n      value: 'disconnected' | 'connecting' | 'connected';\n      reason?: never;\n    }\n  | {\n      value: 'error';\n      reason: string;\n    };\n\nexport type VoiceContextType = {\n  connect: () => Promise<void>;\n  disconnect: () => void;\n  fft: number[];\n  isMuted: boolean;\n  isPlaying: boolean;\n  messages: (\n    | UserTranscriptMessage\n    | AssistantTranscriptMessage\n    | ConnectionMessage\n    | UserInterruptionMessage\n    | JSONErrorMessage\n  )[];\n  lastVoiceMessage: AssistantTranscriptMessage | null;\n  lastUserMessage: UserTranscriptMessage | null;\n  clearMessages: () => void;\n  mute: () => void;\n  unmute: () => void;\n  readyState: VoiceReadyState;\n  sendUserInput: (text: string) => void;\n  sendAssistantInput: (text: string) => void;\n  sendSessionSettings: (sessionSettings: SessionSettings) => void;\n  status: VoiceStatus;\n  micFft: number[];\n  error: VoiceError | null;\n  isAudioError: boolean;\n  isError: boolean;\n  isMicrophoneError: boolean;\n  isSocketError: boolean;\n  callDurationTimestamp: string | null;\n};\n\nconst VoiceContext = createContext<VoiceContextType | null>(null);\n\nexport type VoiceProviderProps = PropsWithChildren<\n  Parameters<typeof createSocketConfig>[0]\n> & {\n  sessionSettings?: SessionSettings;\n  onMessage?: (message: JSONMessage) => void;\n  onError?: (err: VoiceError) => void;\n  onOpen?: () => void;\n  onClose?: VoiceEventMap['close'];\n  /**\n   * @default true\n   * @description Clear messages when the voice is disconnected.\n   */\n  clearMessagesOnDisconnect?: boolean;\n  /**\n   * @default 100\n   * @description The maximum number of messages to keep in memory.\n   */\n  messageHistoryLimit?: number;\n};\n\nexport const useVoice = () => {\n  const ctx = useContext(VoiceContext);\n  if (!ctx) {\n    throw new Error('useVoice must be used within an VoiceProvider');\n  }\n  return ctx;\n};\n\nexport const VoiceProvider: FC<VoiceProviderProps> = ({\n  children,\n  clearMessagesOnDisconnect = true,\n  messageHistoryLimit = 100,\n  sessionSettings,\n  ...props\n}) => {\n  const {\n    timestamp: callDurationTimestamp,\n    start: startTimer,\n    stop: stopTimer,\n  } = useCallDuration();\n\n  const [status, setStatus] = useState<VoiceStatus>({\n    value: 'disconnected',\n  });\n\n  // error handling\n  const [error, setError] = useState<VoiceError | null>(null);\n  const isError = error !== null;\n  const isMicrophoneError = error?.type === 'mic_error';\n  const isSocketError = error?.type === 'socket_error';\n  const isAudioError = error?.type === 'audio_error';\n\n  const onError = useRef(props.onError ?? noop);\n  onError.current = props.onError ?? noop;\n\n  const onClose = useRef(props.onClose ?? noop);\n  onClose.current = props.onClose ?? noop;\n\n  const messageStore = useMessages({\n    sendMessageToParent: props.onMessage,\n    messageHistoryLimit,\n  });\n\n  const updateError = useCallback((err: VoiceError | null) => {\n    setError(err);\n    if (err !== null) {\n      onError.current?.(err);\n    }\n  }, []);\n\n  const onClientError: NonNullable<\n    Parameters<typeof useVoiceClient>[0]['onError']\n  > = useCallback(\n    (message, err) => {\n      stopTimer();\n      updateError({ type: 'socket_error', message, error: err });\n    },\n    [updateError],\n  );\n\n  const config = createSocketConfig(props);\n\n  const player = useSoundPlayer({\n    onError: (message) => {\n      updateError({ type: 'audio_error', message });\n    },\n    onPlayAudio: (id: string) => {\n      messageStore.onPlayAudio(id);\n    },\n  });\n\n  const { streamRef, getStream, permission: micPermission } = useEncoding();\n\n  const client = useVoiceClient({\n    onAudioMessage: (message: AudioOutputMessage) => {\n      player.addToQueue(message);\n    },\n    onMessage: useCallback(\n      (\n        message:\n          | UserTranscriptMessage\n          | AssistantTranscriptMessage\n          | UserInterruptionMessage\n          | JSONErrorMessage,\n      ) => {\n        // store message\n        messageStore.onMessage(message);\n\n        if (message.type === 'user_interruption') {\n          player.clearQueue();\n        }\n      },\n      [player],\n    ),\n    onError: onClientError,\n    onOpen: useCallback(() => {\n      startTimer();\n      messageStore.createConnectMessage();\n      props.onOpen?.();\n    }, [messageStore, props, startTimer]),\n    onClose: useCallback<NonNullable<VoiceEventMap['close']>>(\n      (event) => {\n        stopTimer();\n        messageStore.createDisconnectMessage();\n        onClose.current?.(event);\n      },\n      [messageStore, stopTimer],\n    ),\n  });\n\n  const mic = useMicrophone({\n    streamRef,\n    onAudioCaptured: useCallback((arrayBuffer) => {\n      try {\n        client.sendAudio(arrayBuffer);\n      } catch (e) {\n        const message = e instanceof Error ? e.message : 'Unknown error';\n        updateError({ type: 'socket_error', message });\n      }\n    }, []),\n    onError: useCallback(\n      (message) => {\n        updateError({ type: 'mic_error', message });\n      },\n      [updateError],\n    ),\n  });\n\n  const connect = useCallback(async () => {\n    updateError(null);\n    setStatus({ value: 'connecting' });\n    const permission = await getStream();\n\n    if (permission === 'denied') {\n      const error: VoiceError = {\n        type: 'mic_error',\n        message: 'Microphone permission denied',\n      };\n      updateError(error);\n      return Promise.reject(error);\n    }\n\n    try {\n      await client\n        .connect({\n          ...config,\n        })\n        .then(() => {\n          if (\n            sessionSettings !== undefined &&\n            Object.keys(sessionSettings).length > 0\n          ) {\n            client.sendSessionSettings(sessionSettings);\n          }\n        });\n    } catch (e) {\n      const error: VoiceError = {\n        type: 'socket_error',\n        message: 'We could not connect to the voice. Please try again.',\n      };\n      updateError(error);\n      return Promise.reject(error);\n    }\n\n    try {\n      const [micPromise, playerPromise] = await Promise.allSettled([\n        mic.start(),\n        player.initPlayer(),\n      ]);\n\n      if (\n        micPromise.status === 'fulfilled' &&\n        playerPromise.status === 'fulfilled'\n      ) {\n        setStatus({ value: 'connected' });\n      }\n    } catch (e) {\n      const error: VoiceError = {\n        type: 'audio_error',\n        message:\n          e instanceof Error\n            ? e.message\n            : 'We could not connect to audio. Please try again.',\n      };\n      updateError(error);\n    }\n  }, [client, config, getStream, mic, player, updateError]);\n\n  const disconnectFromVoice = useCallback(() => {\n    client.disconnect();\n    player.stopAll();\n    mic.stop();\n    if (clearMessagesOnDisconnect) {\n      messageStore.clearMessages();\n    }\n  }, [client, player, mic]);\n\n  const disconnect = useCallback(\n    (disconnectOnError?: boolean) => {\n      if (micPermission === 'denied') {\n        setStatus({ value: 'error', reason: 'Microphone permission denied' });\n      }\n\n      stopTimer();\n\n      disconnectFromVoice();\n\n      if (status.value !== 'error' && !disconnectOnError) {\n        // if status was 'error', keep the error status so we can show the error message to the end user.\n        // otherwise, set status to 'disconnected'\n        setStatus({ value: 'disconnected' });\n      }\n    },\n    [micPermission, stopTimer, disconnectFromVoice, status.value],\n  );\n\n  useEffect(() => {\n    if (\n      error !== null &&\n      status.value !== 'error' &&\n      status.value !== 'disconnected'\n    ) {\n      // If the status is ever set to `error`, disconnect the voice.\n      setStatus({ value: 'error', reason: error.message });\n      disconnectFromVoice();\n    }\n  }, [status.value, disconnect, disconnectFromVoice, error]);\n\n  const ctx = useMemo(\n    () =>\n      ({\n        connect,\n        disconnect,\n        fft: player.fft,\n        micFft: mic.fft,\n        isMuted: mic.isMuted,\n        isPlaying: player.isPlaying,\n        messages: messageStore.messages,\n        lastVoiceMessage: messageStore.lastVoiceMessage,\n        lastUserMessage: messageStore.lastUserMessage,\n        clearMessages: messageStore.clearMessages,\n        mute: mic.mute,\n        readyState: client.readyState,\n        sendUserInput: client.sendUserInput,\n        sendAssistantInput: client.sendAssistantInput,\n        sendSessionSettings: client.sendSessionSettings,\n        status,\n        unmute: mic.unmute,\n        error,\n        isAudioError,\n        isError,\n        isMicrophoneError,\n        isSocketError,\n        callDurationTimestamp,\n      }) satisfies VoiceContextType,\n    [\n      connect,\n      disconnect,\n      player.fft,\n      player.isPlaying,\n      mic.fft,\n      mic.isMuted,\n      mic.mute,\n      mic.unmute,\n      messageStore.messages,\n      messageStore.lastVoiceMessage,\n      messageStore.lastUserMessage,\n      messageStore.clearMessages,\n      client.readyState,\n      client.sendUserInput,\n      client.sendAssistantInput,\n      client.sendSessionSettings,\n      status,\n      error,\n      isAudioError,\n      isError,\n      isMicrophoneError,\n      isSocketError,\n      callDurationTimestamp,\n    ],\n  );\n\n  return <VoiceContext.Provider value={ctx}>{children}</VoiceContext.Provider>;\n};\n","export const noop = () => {};\n","import { intervalToDuration } from 'date-fns';\nimport { useCallback, useEffect, useRef, useState } from 'react';\n\nexport const useCallDuration = () => {\n  const interval = useRef<number | null>(null);\n  const startTime = useRef<number | null>(null);\n\n  const [timestamp, setTimestamp] = useState<string | null>(null);\n\n  const start = useCallback(() => {\n    startTime.current = Date.now();\n\n    setTimestamp('00:00:00');\n\n    interval.current = window.setInterval(() => {\n      if (startTime.current) {\n        const duration = intervalToDuration({\n          start: startTime.current,\n          end: Date.now(),\n        });\n\n        const hours = (duration.hours ?? 0).toString().padStart(2, '0');\n        const minutes = (duration.minutes ?? 0).toString().padStart(2, '0');\n        const seconds = (duration.seconds ?? 0).toString().padStart(2, '0');\n\n        setTimestamp(`${hours}:${minutes}:${seconds}`);\n      }\n    }, 500);\n  }, []);\n\n  const stop = useCallback(() => {\n    if (interval.current) {\n      window.clearInterval(interval.current);\n      interval.current = null;\n    }\n  }, []);\n\n  const reset = useCallback(() => {\n    setTimestamp(null);\n  }, []);\n\n  useEffect(() => {\n    // clean up on unmount\n    return () => {\n      if (interval.current) {\n        window.clearInterval(interval.current);\n        interval.current = null;\n      }\n    };\n  }, []);\n\n  return { timestamp, start, stop, reset };\n};\n","// cspell:ignore dataavailable\nimport { checkForAudioTracks, getAudioStream } from '@humeai/voice';\nimport { useCallback, useRef, useState } from 'react';\n\ntype PermissionStatus = 'prompt' | 'granted' | 'denied';\n\nconst useEncoding = () => {\n  const [permission, setPermission] = useState<PermissionStatus>('prompt');\n\n  const streamRef = useRef<MediaStream | null>(null);\n\n  const getStream = useCallback(async () => {\n    try {\n      const stream = await getAudioStream();\n\n      setPermission('granted');\n      streamRef.current = stream;\n\n      checkForAudioTracks(stream);\n\n      return 'granted' as const;\n    } catch (e) {\n      setPermission('denied');\n      return 'denied' as const;\n    }\n  }, []);\n\n  return {\n    streamRef,\n    getStream,\n    permission,\n  };\n};\n\nexport { useEncoding };\n","import type { JSONErrorMessage, UserInterruptionMessage } from '@humeai/voice';\nimport {\n  type AssistantTranscriptMessage,\n  type JSONMessage,\n  type UserTranscriptMessage,\n} from '@humeai/voice';\nimport { useCallback, useState } from 'react';\n\nimport type { ConnectionMessage } from './connection-message';\nimport { keepLastN } from '../utils';\n\nexport const useMessages = ({\n  sendMessageToParent,\n  messageHistoryLimit,\n}: {\n  sendMessageToParent?: (\n    message:\n      | UserTranscriptMessage\n      | AssistantTranscriptMessage\n      | UserInterruptionMessage\n      | JSONErrorMessage,\n  ) => void;\n  messageHistoryLimit: number;\n}) => {\n  const [voiceMessageMap, setVoiceMessageMap] = useState<\n    Record<string, AssistantTranscriptMessage>\n  >({});\n\n  const [messages, setMessages] = useState<\n    Array<\n      | AssistantTranscriptMessage\n      | UserTranscriptMessage\n      | ConnectionMessage\n      | UserInterruptionMessage\n      | JSONErrorMessage\n    >\n  >([]);\n\n  const [lastVoiceMessage, setLastVoiceMessage] =\n    useState<AssistantTranscriptMessage | null>(null);\n  const [lastUserMessage, setLastUserMessage] =\n    useState<UserTranscriptMessage | null>(null);\n\n  const createConnectMessage = useCallback(() => {\n    setMessages((prev) =>\n      prev.concat([\n        {\n          type: 'socket_connected',\n          receivedAt: new Date(),\n        },\n      ]),\n    );\n  }, []);\n\n  const createDisconnectMessage = useCallback(() => {\n    setMessages((prev) =>\n      prev.concat([\n        {\n          type: 'socket_disconnected',\n          receivedAt: new Date(),\n        },\n      ]),\n    );\n  }, []);\n\n  const onMessage = useCallback((message: JSONMessage) => {\n    /* \n      1. message comes in from the backend\n        - if the message IS NOT AssistantTranscriptMessage, store in `messages` immediately  \n        - if the message is an AssistantTranscriptMessage, stored in `voiceMessageMap`\n      2. audio clip plays\n        - find the AssistantTranscriptMessage with a matching ID, and store it in `messages`\n        - remove the AssistantTranscriptMessage from `voiceMessageMap`\n    */\n    switch (message.type) {\n      case 'assistant_message':\n        // for assistant messages, `sendMessageToParent` is called in `onPlayAudio`\n        // in order to line up the transcript event with the correct audio clip\n        setVoiceMessageMap((prev) => ({\n          ...prev,\n          [message.id]: message,\n        }));\n        break;\n      case 'user_message':\n        sendMessageToParent?.(message);\n        setLastUserMessage(message);\n        setMessages((prev) => {\n          return keepLastN(messageHistoryLimit, prev.concat([message]));\n        });\n        break;\n      case 'user_interruption':\n        sendMessageToParent?.(message);\n        setMessages((prev) => {\n          return keepLastN(messageHistoryLimit, prev.concat([message]));\n        });\n        break;\n      case 'error':\n        sendMessageToParent?.(message);\n        setMessages((prev) => {\n          return keepLastN(messageHistoryLimit, prev.concat([message]));\n        });\n        break;\n      default:\n        break;\n    }\n  }, []);\n\n  const onPlayAudio = useCallback(\n    (id: string) => {\n      const matchingTranscript = voiceMessageMap[id];\n      if (matchingTranscript) {\n        sendMessageToParent?.(matchingTranscript);\n        setLastVoiceMessage(matchingTranscript);\n        setMessages((prev) => {\n          return keepLastN(\n            messageHistoryLimit,\n            prev.concat([matchingTranscript]),\n          );\n        });\n        // remove the message from the map to ensure we don't\n        // accidentally push it to the messages array more than once\n        setVoiceMessageMap((prev) => {\n          const newMap = { ...prev };\n          delete newMap[id];\n          return newMap;\n        });\n      }\n    },\n    [voiceMessageMap, sendMessageToParent, messageHistoryLimit],\n  );\n\n  const clearMessages = useCallback(() => {\n    setMessages([]);\n    setLastVoiceMessage(null);\n    setLastUserMessage(null);\n    setVoiceMessageMap({});\n  }, []);\n\n  return {\n    createConnectMessage,\n    createDisconnectMessage,\n    onMessage,\n    onPlayAudio,\n    clearMessages,\n    messages,\n    lastVoiceMessage,\n    lastUserMessage,\n  };\n};\n","export const keepLastN = <T>(n: number, arr: T[]): T[] => {\n  if (arr.length <= n) {\n    return arr;\n  }\n  return arr.slice(arr.length - n);\n};\n","import type {\n  AssistantTranscriptMessage,\n  AudioOutputMessage,\n  JSONErrorMessage,\n  SessionSettings,\n  SocketConfig,\n  UserInterruptionMessage,\n  UserTranscriptMessage,\n  VoiceEventMap,\n} from '@humeai/voice';\nimport { VoiceClient } from '@humeai/voice';\nimport { useCallback, useRef, useState } from 'react';\n\nexport enum VoiceReadyState {\n  IDLE = 'idle',\n  CONNECTING = 'connecting',\n  OPEN = 'open',\n  CLOSED = 'closed',\n}\n\nexport const useVoiceClient = (props: {\n  onAudioMessage?: (message: AudioOutputMessage) => void;\n  onMessage?: (\n    message:\n      | UserTranscriptMessage\n      | AssistantTranscriptMessage\n      | UserInterruptionMessage\n      | JSONErrorMessage,\n  ) => void;\n  onError?: (message: string, error?: Error) => void;\n  onOpen?: () => void;\n  onClose?: VoiceEventMap['close'];\n}) => {\n  const client = useRef<VoiceClient | null>(null);\n\n  const [readyState, setReadyState] = useState<VoiceReadyState>(\n    VoiceReadyState.IDLE,\n  );\n\n  // this pattern might look hacky but it allows us to use the latest props\n  // in callbacks set up inside useEffect without re-rendering the useEffect\n  const onAudioMessage = useRef<typeof props.onAudioMessage>(\n    props.onAudioMessage,\n  );\n  onAudioMessage.current = props.onAudioMessage;\n\n  const onMessage = useRef<typeof props.onMessage>(props.onMessage);\n  onMessage.current = props.onMessage;\n\n  const onError = useRef<typeof props.onError>(props.onError);\n  onError.current = props.onError;\n\n  const onOpen = useRef<typeof props.onOpen>(props.onOpen);\n  onOpen.current = props.onOpen;\n\n  const onClose = useRef<typeof props.onClose>(props.onClose);\n  onClose.current = props.onClose;\n\n  const connect = useCallback((config: SocketConfig) => {\n    return new Promise((resolve, reject) => {\n      client.current = VoiceClient.create(config);\n\n      client.current.on('open', () => {\n        onOpen.current?.();\n        setReadyState(VoiceReadyState.OPEN);\n        resolve(VoiceReadyState.OPEN);\n      });\n\n      client.current.on('message', (message) => {\n        if (message.type === 'audio_output') {\n          onAudioMessage.current?.(message);\n        }\n\n        if (\n          message.type === 'assistant_message' ||\n          message.type === 'user_message' ||\n          message.type === 'user_interruption' ||\n          message.type === 'error'\n        ) {\n          onMessage.current?.(message);\n        }\n      });\n\n      client.current.on('close', (event) => {\n        onClose.current?.(event);\n        setReadyState(VoiceReadyState.CLOSED);\n      });\n\n      client.current.on('error', (e) => {\n        const message = e instanceof Error ? e.message : 'Unknown error';\n        onError.current?.(message, e instanceof Error ? e : undefined);\n        reject(e);\n      });\n\n      setReadyState(VoiceReadyState.CONNECTING);\n\n      client.current.connect();\n    });\n  }, []);\n\n  const disconnect = useCallback(() => {\n    setReadyState(VoiceReadyState.IDLE);\n    client.current?.disconnect();\n  }, []);\n\n  const sendSessionSettings = useCallback(\n    (sessionSettings: SessionSettings) => {\n      client.current?.sendSessionSettings(sessionSettings);\n    },\n    [],\n  );\n\n  const sendAudio = useCallback((arrayBuffer: ArrayBufferLike) => {\n    client.current?.sendAudio(arrayBuffer);\n  }, []);\n\n  const sendUserInput = useCallback((text: string) => {\n    client.current?.sendUserInput(text);\n  }, []);\n\n  const sendAssistantInput = useCallback((text: string) => {\n    client.current?.sendAssistantInput(text);\n  }, []);\n\n  return {\n    readyState,\n    sendSessionSettings,\n    sendAudio,\n    connect,\n    disconnect,\n    sendUserInput,\n    sendAssistantInput,\n  };\n};\n","export * from './lib/useSoundPlayer';\nexport * from './lib/useMicrophone';\nexport * from './lib/VoiceProvider';\nexport * from './lib/useVoiceClient';\nexport * from './lib/connection-message';\n\nexport {\n  type SocketConfig,\n  Channels,\n  TTSService,\n  AudioEncoding,\n  type AssistantEndMessage,\n  type AssistantTranscriptMessage,\n  type AudioMessage,\n  type AudioOutputMessage,\n  type JSONMessage,\n  type TimeSlice,\n  type UserInterruptionMessage,\n  type UserTranscriptMessage,\n  LanguageModelOption,\n} from '@humeai/voice';\n"],"mappings":"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","names":["useCallback","useRef","useState","useState","useRef","useCallback","useCallback","useEffect","useRef","useState","useCallback","useEffect","useRef","useState","useCallback","useRef","useState","useCallback","useState","useState","useCallback","useCallback","useRef","useState","VoiceReadyState","useState","useRef","useCallback","error","useEffect"]}